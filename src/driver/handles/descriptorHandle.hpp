#pragma once

#include "../../util/windowsLean.hpp"
#include <sql.h>
#include <sqlext.h>
#include <string>
#include <vector>


struct DescriptorField {
    // SQL Data type of the field
    SQLSMALLINT odbcDataType = SQL_UNKNOWN_TYPE;
    // C Data type of the field
    SQLSMALLINT bufferCDataType = SQL_UNKNOWN_TYPE;
    // Data buffer, if column is bound
    SQLPOINTER bufferPtr = nullptr;
    // Length of the data buffer
    SQLLEN bufferLength = -1;
    // Length/indicator buffer.
    SQLLEN* bufferStrLenOrIndPtr = nullptr;
    // String name of the column being described
    std::string columnName;
    // The raw type name as returned by Trino
    std::string trinoRawTypeName;
    /* Concise data type */
    // SQLSMALLINT concise_type;
    /* Pointer to the indicator buffer (for nulls) */
    // SQLPOINTER indicator_ptr;
    /* Pointer to the octet length buffer */
    // SQLPOINTER octet_length_ptr;

    // Precision and Scale of the data.
    // Decimals have both a precision and scale. Integral and floating
    // point types have precision but no fixed scale.
    // This is undefined for many other types, so we'll just throw a
    // default zero into both of them.
    SQLCHAR scale     = 0;
    SQLCHAR precision = 0;
    // The base of the numbers specified for the precions/scale of this data.
    // Floats and ints use Binary (base 2) precision. Decimal numbers use
    // base 10 precision. Most other types use not applicable (0).
    // Default to not applicable.
    SQLINTEGER numPrecRadix = 0;
    // TODO: Nullability of the column. Not implemented yet. I don't see how to
    // get this information from Trino for any given query.
    SQLSMALLINT nullable = SQL_NULLABLE_UNKNOWN;
    // The size of this field in undefined units. For varchars, this is the
    // character length.
    SQLINTEGER length = SQL_NO_TOTAL;
    // The maximum possible number of bytes required to contain values in this
    // field? It could be longer than the `length` due to encoding such as
    // UTF-8.
    SQLLEN octetLength = SQL_NO_TOTAL;
    // Un-signedness of the field? Default to true to accomodate non-numeric
    // types as well.
    bool isUnsigned = true;
    // All trino columns are named. If they aren't explicitly named,
    // they get the "_col0", "_col1" autogenerated names.
    bool named = true;
};

class Descriptor {
  private:
    std::vector<DescriptorField> fields;

  public:
    Descriptor(SQLSMALLINT columnCount = 0);
    ~Descriptor();

    void setField(SQLSMALLINT columnIndex, DescriptorField& field);
    DescriptorField getField(SQLSMALLINT columnIndex);
    const DescriptorField& getFieldRef(SQLSMALLINT columnIndex);
    void resize(SQLSMALLINT newSize);
    void reset();
    SQLSMALLINT getColumnCount();

    // HEADER FIELDS
    // Header fields are fields that describe the descriptor as a whole.
    // Don't confuse these with record fields that describe individual
    // columns or parameters.

    // The size of the result array. Defaults to 1, because this
    // driver operates on one row at a time.
    SQLULEN Field_ArraySize = 1;
    // Holds the status of each row during bulk operations.
    // We'll initialize it to a length of 1 because we only
    // want to support a single row at a time.
    SQLUSMALLINT* Field_ArrayStatusPtr = nullptr;
    // An optional fixed offset to apply to add to data, indicator, and
    // octet length pointers. Defaults to a null pointer (no offset).
    SQLLEN* Field_BindOffsetPtr = nullptr;
    // How was this descriptor allocated. We'l default to the "AUTO" type.
    // If the descriptor is allocated by a call to allocHandle, then
    // it's safe to assume it was allocated by an application since this
    // driver does not call allocHandle for descriptor handles.
    SQLSMALLINT Field_AllocType = SQL_DESC_ALLOC_AUTO;
    // How does the application bind data (SQLBindCol)?
    // Docs disagree if this is signed or not. Trying unsigned.
    SQLUINTEGER Field_BindType = SQL_BIND_BY_COLUMN;
    // What is the 1-based index of the highest numbered record that contains
    // data? For record descriptors, this is the highest numbered bound column.
    // For parameter descriptors, this is the highest numbered bound parameter.
    // Zero means there are no bound columns (it does not refer to the bookmark
    // column).
    SQLSMALLINT Field_Count = 0;
    // Tells the number of rows fetched after a call to SQLFetch, and a few
    // other fetch-like operations.
    SQLULEN* Field_RowsProcessedPtr = nullptr;
};
